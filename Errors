gil@gil-VirtualBox:~/Desktop/compilation course/compiler 2025/part2$ yacc -d -v parser.y
parser.y: warning: 2 shift/reduce conflicts [-Wconflicts-sr]
parser.y: note: rerun with option '-Wcounterexamples' to generate conflict counterexamples
gil@gil-VirtualBox:~/Desktop/compilation course/compiler 2025/part2$ lex scanner.l
gil@gil-VirtualBox:~/Desktop/compilation course/compiler 2025/part2$ gcc -o parser y.tab.c lex.yy.c semantic.c symbol_table.c -I. -lfl
parser.y: In function ‘yyparse’:
parser.y:468:45: error: ‘currentFunction’ undeclared (first use in this function)
  468 |                          if(!semCheckReturn(currentFunction,ret))
      |                                             ^~~~~~~~~~~~~~~
parser.y:468:45: note: each undeclared identifier is reported only once for each function it appears in
parser.y:468:30: error: too many arguments to function ‘semCheckReturn’
  468 |                          if(!semCheckReturn(currentFunction,ret))
      |                              ^~~~~~~~~~~~~~
In file included from parser.y:12:
semantic.h:27:5: note: declared here
   27 | int semCheckReturn(Type ret);
      |     ^~~~~~~~~~~~~~
parser.y:581:61: warning: passing argument 1 of ‘semTypeOfNode’ from incompatible pointer type [-Wincompatible-pointer-types]
  581 |                         Type cond = semTypeOfNode($7);
      |                                                   ~~~~      ^       
      |                                                             |
      |                                                             char *
semantic.h:16:27: note: expected ‘node *’ {aka ‘struct node *’} but argument is of type ‘char *’
   16 | Type  semTypeOfNode(node *n);   /* (optional) */
      |                     ~~~~~~^
parser.y:619:27: error: conflicting types for ‘cond’; have ‘node *’ {aka ‘struct node *’}
  619 |                     node* cond = $7;
      |                           ^~~~
parser.y:609:26: note: previous definition of ‘cond’ with type ‘Type’
  609 |                     Type cond = semTypeOfNode($7);
      |                          ^~~~
parser.y:900:29: error: expected expression before ‘Type’
  900 |                             Type r = resultUnary('&', a);
      |                             ^~~~
parser.y:902:50: error: ‘r’ undeclared (first use in this function)
  902 |                             $$->type = r;
      |                                                  ^
